# üß™ Taller - Escenas Param√©tricas: Creaci√≥n de Objetos desde Datos

## üìÖ Fecha

`2025-05-05` ‚Äì Fecha de realizaci√≥n

---

## üéØ Objetivo del Taller

El objetivo principal de este taller es aprender a generar objetos y escenas 3D de manera program√°tica utilizando Python. Se busca explorar c√≥mo crear geometr√≠a 3D flexiblemente a partir de datos estructurados (como archivos CSV o JSON), empleando bucles y condicionales para controlar par√°metros como posici√≥n, forma, tama√±o y color, y finalmente exportar las escenas resultantes a formatos est√°ndar como OBJ, STL o PLY.

---

## üß† Conceptos Aprendidos

Lista de conceptos clave aplicados en el taller:


*   **Generaci√≥n Procedural 3D:** Crear geometr√≠a mediante algoritmos en lugar de modelado manual.
*   **Modelado Param√©trico:** Definir objetos 3D a trav√©s de par√°metros (coordenadas, tama√±o, tipo).
*   **Dise√±o Basado en Datos:** Utilizar datos externos (CSV/JSON) como fuente para la creaci√≥n de contenido.
*   **Manipulaci√≥n de Geometr√≠a 3D:** Creaci√≥n y manejo de primitivas (Cubos, Esferas, Cilindros).
*   **Programaci√≥n con Python:** Uso de estructuras de control (bucles `for`, condicionales `if/elif`).
*   **Bibliotecas Python 3D:** Uso pr√°ctico de `vedo`, `trimesh` y `open3d` para crear, visualizar y manipular mallas 3D.
*   **Manejo de Datos:** Lectura y procesamiento de archivos CSV/JSON con las bibliotecas `csv` y `json`, y uso de `numpy` para operaciones num√©ricas.
*   **Exportaci√≥n de Formatos 3D:** Guardar las escenas/objetos generados en formatos est√°ndar de la industria como `.obj`, `.stl`, `.ply`.

---

## üîß Herramientas y Entornos

Especifica los entornos usados:

- Python Jupyter Notebook (`.ipynb`)
*   **Bibliotecas Python:**
    *   `vedo`: Para creaci√≥n, visualizaci√≥n y manipulaci√≥n inicial de objetos 3D.
    *   `trimesh`: Para procesamiento de mallas y exportaci√≥n (especialmente escenas combinadas).
    *   `open3d-python`: Para conversi√≥n de mallas y exportaci√≥n (especialmente formato PLY).
    *   `numpy`: Para manejo eficiente de arrays num√©ricos (coordenadas, v√©rtices, caras).
    *   `csv`: Para leer datos desde archivos CSV.
    *   `json`: (Opcional, si se usara JSON) Para leer datos desde archivos JSON.
    *   `os`: Para manejo de rutas de archivos y directorios.


---

## üìÅ Estructura del Proyecto
```
2025-05-05_taller_escenas_parametricas/
‚îú‚îÄ‚îÄ threejs/
‚îú‚îÄ‚îÄ datos/         # Archivo de datos de entrada
‚îú‚îÄ‚îÄ python/        # Notebook con el c√≥digo del taller
‚îÇ ‚îú‚îÄ‚îÄ exports/     # Carpeta con los archivos 3D exportados
‚îú‚îÄ‚îÄ resultados/    # Carpeta para resultados visuales
‚îî‚îÄ‚îÄ README.md      # Este archivo de documentaci√≥n
```
## üß™ Implementaci√≥n

Explica el proceso:

### üîπ Etapas realizadas

#### üêç Python
1. **Preparaci√≥n de Datos:**  Se carg√≥ el archivo `datos_escena.csv` con informaci√≥n sobre cada objeto (`x`, `y`, `z`, `forma`, `color`, `tamano`) mediante la funci√≥n `leer_csv`, generando una lista de diccionarios.

2. **Generaci√≥n de Geometr√≠a Param√©trica:**  Se recorri√≥ la lista de objetos, extrayendo sus atributos. Seg√∫n el campo `forma`, se cre√≥ la primitiva correspondiente de `vedo` (`Cube`, `Sphere`, `Cylinder`), asignando posici√≥n, tama√±o y color. Todos los objetos se almacenaron en `objetos_generados`.

3. **Exportaci√≥n Multi-Biblioteca:**
   - **Vedo:** Se combinaron los objetos (`merge`) y se exportaron en `.obj` y `.stl`.
   - **Trimesh:** Se convirtieron a mallas trianguladas, se agruparon en una `Scene` y se exportaron a `.stl`.
   - **Open3D:** Se transformaron a `TriangleMesh` (con triangulaci√≥n y normales) y se exportaron individualmente en `.ply`.

#### üåê React.js
1. Generaci√≥n program√°tica de una lista de objetos con coordenadas y par√°metros.
2. Parametrizaci√≥n de propiedades usando `Leva`.
3. Renderizado de la escena con `Three.js` y animaci√≥n por frame.
4. Captura de resultados animados con Peek.

###  üîπ C√≥digo relevante

### üêç Python  
El n√∫cleo del proceso reside en este bucle, que recorre cada registro de datos le√≠do (por ejemplo, del CSV). Para cada uno, extrae los par√°metros definidos (posici√≥n, forma, color, tama√±o) y emplea una estructura condicional if/elif para determinar din√°micamente qu√© primitiva 3D espec√≠fica (vedo.Cube, vedo.Sphere, etc.) debe ser creada bas√°ndose en el par√°metro forma. La biblioteca vedo se encarga de instanciar el objeto geom√©trico correspondiente con dichos par√°metros, y cada objeto resultante se acumula en la lista objetos_generados, construyendo as√≠ la escena completa de forma program√°tica y basada en los datos de entrada para su posterior visualizaci√≥n o exportaci√≥n.

```python
# Procesar los datos y generar los objetos 3D
for i, dato in enumerate(datos):
    # Coordenadas 3D
    punto = [dato["x"], dato["y"], dato["z"]]

    # Forma y par√°metros
    forma = dato["forma"]
    color = dato["color"]
    tamano = dato["tamano"]

    print(f"\nProcesando punto {i}: {punto} - Forma: {forma}, Color: {color}, Tama√±o: {tamano}")

    # Crear el objeto correspondiente seg√∫n la forma
    objeto_3d = None
    if forma == "cubo":
        objeto_3d = vedo.Cube(pos=punto, side=tamano, c=color)
    elif forma == "esfera":
        objeto_3d = vedo.Sphere(pos=punto, r=tamano, c=color)
    elif forma == "cilindro":
        objeto_3d = vedo.Cylinder(pos=punto, r=tamano, height=tamano*2, c=color)

    # A√±adir el objeto generado a la lista (si se cre√≥ uno v√°lido)
    if objeto_3d:
        objetos_generados.append(objeto_3d)
```

### üåê React Three Fiber (App.jsx)
Utiliza el hook useFrame de React Three Fiber para ejecutar una funci√≥n en cada frame del renderizado. Si el par√°metro animateRotation est√° activado, se aplica una rotaci√≥n incremental en el eje Y a todo el grupo de objetos (groupRef). Esto genera una rotaci√≥n suave y constante de la escena 3D.

La generaci√≥n din√°mica de objetos se realiza mediante un mapeo (map) sobre el array base rawData, creando un nuevo arreglo data cuyas propiedades ‚Äîposici√≥n, color, rotaci√≥n y escala‚Äî se ajustan en tiempo real seg√∫n los controles definidos en la interfaz. Esto permite modificar el espaciado entre objetos, aplicar un color uniforme, alternar entre rotaci√≥n aleatoria o fija, y definir un tama√±o base com√∫n, logrando as√≠ una visualizaci√≥n param√©trica y flexible.

```jsx
// Animaci√≥n por frame y mapeo din√°mico de objetos 3D
useFrame(() => {
  if (animateRotation && groupRef.current) {
    groupRef.current.rotation.y += 0.01
  }
})

const data = rawData.map((item, i) => ({
  ...item,
  position: [i * spacing, 0, 0],
  color: colorBase,
  rotation: randomizeRotation ? Math.random() * Math.PI : item.rotation,
  scale: baseSize,
}))
```
Este bloque define los par√°metros ajustables desde la interfaz de usuario. Se pueden cambiar en tiempo real sin recargar la escena:

```jsx
const {
  globalScale,
  geometryType,
  baseSize,
  spacing,
  colorBase,
  lightIntensity,
  randomizeRotation,
  animateRotation,
} = useControls({
  globalScale: { value: 1, min: 0.1, max: 3 },
  geometryType: { options: { Cube: 'cube', Sphere: 'sphere' } },
  baseSize: { value: 1, min: 0.2, max: 3 },
  spacing: { value: 2, min: 1, max: 5 },
  colorBase: '#ffaa00',
  lightIntensity: { value: 1, min: 0, max: 10 },
  randomizeRotation: false,
  animateRotation: false,
})

```

## üìä Resultados Visuales
### üêç Python   
![Resultado Python](resultados/PythonResultado.gif)



### üåê React  

![Resultado Processing](resultados/ThreejsResultado.gif)



---

üß© Prompts Usados

- Genera una lista de 20 coordenadas aleatorias en 3D dentro de un cubo de lado 10 usando numpy.
- A partir de una lista de puntos 3D, crea una esfera de radio variable en cada punto usando vedo.
- Recorre un array de puntos y genera una malla de cubos o cilindros alternando entre ellos con un condicional.
- Exporta la escena completa como archivo .OBJ utilizando vedo.write('escena.obj').
- Crear una escena 3D donde 10 objetos se generen din√°micamente desde datos con forma, posici√≥n y color controlables
- Agrega animaci√≥n de rotaci√≥n al grupo completo si se activa un par√°metro booleano
- Dame mejores estilos CSS para que el canvas ocupe todo y tenga una est√©tica profesional

---

üí¨ Reflexi√≥n Final  

Reforc√© mi comprensi√≥n sobre c√≥mo la programaci√≥n puede usarse para automatizar tareas de modelado que ser√≠an repetitivas manualmente, permitiendo crear escenas complejas o variadas simplemente modificando un archivo de datos de entrada. Aprender a interactuar con diferentes bibliotecas 3D de Python (vedo, trimesh, open3d) y entender sus fortalezas y c√≥mo convertir datos entre ellas fue un punto clave.

Ademas practique el del renderizado 3D en la web de forma declarativa usando React Three Fiber, y c√≥mo los datos pueden controlarse en tiempo real gracias a herramientas como Leva. El poder generar escenas de forma din√°mica desde listas de datos abre muchas posibilidades en visualizaci√≥n interactiva, simulaciones y prototipos r√°pidos.

Me parecio bastante interesante ver c√≥mo peque√±os par√°metros pueden alterar por completo la escena, y c√≥mo combinar animaci√≥n con control de interfaz en tiempo real. Mejorar√≠a en el futuro la estructura de los datos, permitiendo cargarlos desde un archivo JSON o API externa, y considerar√≠a exportar las escenas como GLTF o usarlas en entornos m√°s complejos como WebXR.

La parte m√°s desafiante y en la que tuve varios probleas due el uso de trimesh y open3d, para la exportacion de archivos, ya que muchas funciones importantes para realizar la exportacion eran de versiones muy anteirors, ademas de eso me parecio bastante interesante  ver c√≥mo una simple tabla de datos CSV se transformaba en una visualizaci√≥n 3D tangible. El principal desaf√≠o t√©cnico radic√≥ en comprender las diferentes representaciones internas de las mallas en cada biblioteca (especialmente c√≥mo definen las caras/tri√°ngulos) y asegurar que las conversiones y exportaciones se realizaran correctamente para obtener archivos v√°lidos en formatos est√°ndar como OBJ, STL y PLY. La depuraci√≥n de problemas de exportaci√≥n o conversi√≥n requiri√≥ atenci√≥n a los detalles de los tipos de datos y estructuras esperadas por cada funci√≥n.

