# üß™ Importando el Mundo: Visualizaci√≥n y Conversi√≥n de Formatos 3D

## üìÖ Fecha

`2025-05-04` ‚Äì Fecha de realizaci√≥n

---

## üéØ Objetivo del Taller

Explorar la estructura interna y compatibilidad entre formatos de modelos 3D (.OBJ, .STL, .GLTF), aplicando t√©cnicas de an√°lisis geom√©trico, visualizaci√≥n b√°sica y conversi√≥n de formatos utilizando Python y Trimesh.
El objetivo de este taller es comparar y convertir entre los formatos de modelos 3D m√°s comunes: .OBJ, .STL y .GLTF/GLB. Adem√°s, se busca visualizar las diferencias en cuanto a geometr√≠a y materiales en estos formatos, as√≠ como explorar las estructuras internas de los archivos 3D y su compatibilidad con diversas plataformas de visualizaci√≥n.

---

## üß† Conceptos Aprendidos

Lista de conceptos clave aplicados en el taller:

- [x] Transformaciones geom√©tricas (bounding box, volumen, normalizaci√≥n de v√©rtices)
- [x] An√°lisis de mallas 3D (conteo de v√©rtices y caras, detecci√≥n de duplicados, watertight)
- [x] Conversi√≥n entre formatos de modelos 3D (.obj, .stl, .glb)
- [x] Uso de estructuras tipo `Scene` y combinaci√≥n de geometr√≠as m√∫ltiples
- [x] Visualizaci√≥n indirecta mediante inspecci√≥n de propiedades y comparaci√≥n tabular
- [x] Automatizaci√≥n de flujos de an√°lisis y exportaci√≥n
- [x] Carga y visualizaci√≥n de modelos 3D en Three.js
- [x] Comparaci√≥n entre los formatos `.OBJ`, `.STL` y `.GLB`
- [x] C√°lculo del n√∫mero de v√©rtices y propiedades de los modelos
- [x] Uso de React Three Fiber para integrar visualizaci√≥n 3D en aplicaciones React
- [x] Implementaci√≥n de controles de exploraci√≥n (OrbitControls)
- [x] Implementaci√≥n de selectores din√°micos para alternar entre formatos

---

## üîß Herramientas y Entornos

Especifica los entornos usados:

- Python (`trimesh`, `numpy`, `open3d`, `assimp`)
- Jupyter / Google Colab
- Exploraci√≥n de archivos .OBJ, .STL, .GLTF
- React (React Three Fiber, OrbitControls)
- Three.js (OBJLoader, STLLoader, GLTFLoader)
- Webpack o Create React App para la gesti√≥n de proyectos de React
- Visualizaci√≥n y renderizado 3D

---

## üìÅ Estructura del Proyecto
```
2025-04-28_taller_construyendo_mundo_3d/
‚îú‚îÄ‚îÄ python/              # Implentacion python/
‚îú‚îÄ‚îÄ threejs/             # Implentacion react usando threejs/
‚îú‚îÄ‚îÄ datos/               # Modelos 3D originales
‚îú‚îÄ‚îÄ resultados/          # Gifs resultantes, metricas y conversion de modelos
‚îú‚îÄ‚îÄ README.md
```
## üß™ Implementaci√≥n

Explica el proceso:

### üîπ Etapas realizadas

#### üêç Python
1. **Carga de modelos 3D** desde `/datos/`, filtrando por extensiones v√°lidas (.obj, .stl, .glb, .gltf) usando `trimesh`.
2. **An√°lisis de propiedades geom√©tricas**, como v√©rtices, caras, normales, duplicados, volumen, *watertight* y dimensiones del bounding box.
3. **Conversi√≥n automatizada** de cada modelo a formatos .OBJ, .STL y .GLB, usando `modelo.export`.
4. **Comparaci√≥n tabular de m√©tricas clave** (v√©rtices, caras, duplicados, cerrado) entre modelos, mostrada en consola y exportada como `.txt`.
5. **Exportaci√≥n final** de resultados a la carpeta `/resultados/` para uso en visualizadores externos como Three.js.

#### üåê React.js

1. **Carga de modelos 3D**: Utilizamos Three.js junto con los `OBJLoader`, `STLLoader` y `GLTFLoader` para cargar los modelos en los formatos `.OBJ`, `.STL` y `.GLB`.
2. **Conversi√≥n de geometr√≠a**: Para el formato `.STL`, se convirti√≥ la geometr√≠a cargada en un mesh que luego se visualiza con material est√°ndar.
3. **Visualizaci√≥n**: Se implement√≥ un componente React que permite alternar entre los tres formatos y visualizar sus diferencias.
4. **Interactividad**: Se agregaron controles de √≥rbita (OrbitControls) para permitir la exploraci√≥n del modelo en 3D.
5. **C√°lculo de v√©rtices**: Se implement√≥ una funci√≥n que calcula y muestra el n√∫mero de v√©rtices de los modelos cargados.

### üîπ Justificaci√≥n del uso de **GLB** en vez de **GLTF**  

- **GLTF** es un formato de archivo que describe la geometr√≠a, materiales, texturas y animaciones de un modelo 3D, y est√° basado en JSON. Es un formato muy eficiente y ampliamente soportado en la industria. Sin embargo, **GLTF** tiene la limitaci√≥n de ser un formato en texto, lo que puede hacer que los archivos sean m√°s grandes y menos eficientes para la carga en aplicaciones web, debido a la necesidad de realizar m√∫ltiples solicitudes HTTP para cargar texturas y otros recursos.

- **GLB**, por otro lado, es la versi√≥n binaria de **GLTF**, y tiene una ventaja principal: todo el contenido, incluidos los datos de geometr√≠a, materiales, texturas y animaciones, est√° contenido en un solo archivo binario. Esto mejora significativamente la eficiencia en la carga y el manejo de los modelos, ya que reduce el n√∫mero de archivos y solicitudes HTTP necesarios.

Por estas razones, **se eligi√≥ el formato GLB** para este taller, ya que es m√°s adecuado para aplicaciones web interactivas y ofrece mejores tiempos de carga, especialmente cuando se trabaja con modelos complejos que contienen texturas y animaciones.


###  üîπ C√≥digo relevante

### üêç Python  
Este bloque de c√≥digo realiza el an√°lisis central de cada modelo 3D. Extrae propiedades esenciales como cantidad de v√©rtices y caras, presencia de normales, si la malla est√° cerrada (`watertight`), si hay v√©rtices duplicados, as√≠ como el tama√±o del *bounding box* y el volumen estimado (si aplica). Estos datos permiten evaluar la integridad y calidad de los modelos antes de convertirlos a otros formatos:

```python
# Propiedades b√°sicas
print(f"- V√©rtices: {len(modelo.vertices)}")
print(f"- Caras: {len(modelo.faces)}")

# Normales
try:
    _ = modelo.vertex_normals
    print(f"- Normales presentes: S√≠")
except Exception as e:
    print(f"- Normales presentes: No ({str(e)})")

# Watertight (cerrado)
print(f"- ¬øEst√° cerrado (watertight)?: {'S√≠' if modelo.is_watertight else 'No'}")

# V√©rtices duplicados
unicos = np.unique(modelo.vertices, axis=0)
duplicados = len(modelo.vertices) - len(unicos)
if duplicados:
    print(f"- V√©rtices duplicados: {duplicados} ({duplicados / len(modelo.vertices) * 100:.2f}%)")
else:
    print("- No hay v√©rtices duplicados")

# Bounding box y volumen (si aplica)
print(f"- Bounding box (dimensiones): {modelo.bounding_box.extents}")
if modelo.is_volume:
    print(f"- Volumen estimado: {modelo.volume:.3f} unidades¬≥")
```

### üåê React Three Fiber (App.jsx)

- Permitir la visualizaci√≥n comparativa en tiempo real de diferentes formatos de modelo 3D.
- Mostrar informaci√≥n geom√©trica relevante (como el n√∫mero de v√©rtices).
- Brindar una interfaz limpia y controlable para alternar entre formatos desde una UI simple.
- Preparar la base para extender el proyecto a tareas m√°s complejas como an√°lisis de geometr√≠a, comparaci√≥n de materiales, optimizaci√≥n de modelos o exportaci√≥n.

```jsx
import React, { useEffect, Suspense } from 'react';
import { useLoader } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';
import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';
import { STLLoader } from 'three/examples/jsm/loaders/STLLoader';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import * as THREE from 'three';

export default function ModelViewer({ format, onModelLoaded }) {
  const objModel = useLoader(OBJLoader, '/model.obj');
  const stlGeometry = useLoader(STLLoader, '/model.stl');
  const glbModel = useLoader(GLTFLoader, '/model.glb');

  const stlMesh = new THREE.Mesh(stlGeometry, new THREE.MeshStandardMaterial({ color: 'gray' }));

  useEffect(() => {
    if (format === 'OBJ') {
      onModelLoaded(objModel);
    } else if (format === 'STL') {
      onModelLoaded(stlMesh);
    } else if (format === 'GLB') {
      onModelLoaded(glbModel.scene);
    }
  }, [format, objModel, stlMesh, glbModel]);

  return (
    <>
      <ambientLight intensity={0.5} />
      <pointLight position={[10, 10, 10]} />
      <OrbitControls />
      <Suspense fallback={null}>
        {format === 'OBJ' && <primitive object={objModel} />}
        {format === 'STL' && <primitive object={stlMesh} />}
        {format === 'GLB' && <primitive object={glbModel.scene} />}
      </Suspense>
    </>
  );
}
```


## üìä Resultados Visuales
### üêç Python   
#### üìê An√°lisis geom√©trico de un modelo
![Resultado Python](resultados/ResultadosPython/AnalisisPython.png)

#### üìä Comparaci√≥n de m√©tricas entre modelos
![Resultado Python](resultados/ResultadosPython/comparacionPython.png)

#### üîÅ Conversi√≥n a m√∫ltiples formatos (OBJ, STL, GLB)
![Resultado Python](resultados/ResultadosPython/convercionModelos.png)

#### üéûÔ∏è Proceso completo en ejecuci√≥n (GIF)
![Resultado Python](resultados/ResultadosPython/ResultadoPyrhon.gif)


### üåê React  
Modelo .OBJ:
El modelo cargado en formato .OBJ tiene la geometr√≠a correctamente representada, pero no posee materiales ni texturas por defecto. Esto significa que, al visualizarlo, el modelo aparece en un color plano, sin detalles visuales como profundidad o sombras. 

Modelo .STL:
El formato .STL tampoco incluye materiales ni texturas, lo que provoca que el modelo se visualice en un color gris uniforme. Aunque las formas geom√©tricas est√°n representadas correctamente, la falta de informaci√≥n de color y de suavizado de las superficies hace que el modelo luzca m√°s b√°sico en comparaci√≥n con GLB. 

Modelo .GLB:
El formato .GLB, siendo la versi√≥n binaria del GLTF, mantiene toda la informaci√≥n de materiales, texturas y animaciones dentro de un solo archivo. Esto se refleja en una visualizaci√≥n mucho m√°s detallada, con materiales aplicados correctamente, y texturas en las superficies. Este modelo se ve m√°s realista, lo que facilita la percepci√≥n de la profundidad y los detalles del objeto 3D.

![Resultado Processing](resultados/ResultadoThreejs/threejsModelos.gif)



---

üß© Prompts Usados


- ¬øC√≥mo puedo comparar varios modelos 3D y generar una tabla apartir de las metricas obtenidas?
- ¬øCu√°l es la diferencia entre una escena y una malla en Trimesh, y c√≥mo las convierto para analizarlas?
- ¬øC√≥mo visualizo un modelo 3D en Python y guardo una imagen o animaci√≥n del an√°lisis?
- ¬øQu√© diferencias visuales o estructurales hay entre formatos 3D como .OBJ, .STL y .GLB?
- ¬øC√≥mo puedo cargar y visualizar modelos 3D en Three.js?
- ¬øCu√°l es la diferencia entre los formatos GLTF y GLB?
- ¬øC√≥mo puedo contar el n√∫mero de v√©rtices de un modelo 3D en Three.js?

---

üí¨ Reflexi√≥n Final  

Este taller me permiti√≥ reforzar mis conocimientos en el useo y estructura internamente distintos formatos de modelos 3D, m√°s all√° de su apariencia visual. Fue especialmente valioso identificar la importancia del preprocesamiento (como eliminar duplicados o verificar que una malla sea cerrada) antes de realizar conversiones entre formatos.

Ademas,he adquirido una comprensi√≥n m√°s profunda de los formatos 3D y su compatibilidad entre diferentes plataformas. El uso de GLB, como formato binario eficiente, demostr√≥ ser especialmente √∫til para reducir los tiempos de carga y la complejidad en aplicaciones web interactivas. El proceso de implementaci√≥n tambi√©n me permiti√≥ mejorar mis habilidades en React Three Fiber y en la manipulaci√≥n de modelos 3D en Three.js.

El mayor reto fue manejar modelos en formato .glb que conten√≠an m√∫ltiples geometr√≠as; resolver esto mediante trimesh.util.concatenate() fue clave. A futuro, me gustar√≠a integrar esta l√≥gica en una interfaz web con React Three Fiber para observar las diferencias de renderizado en tiempo real.

